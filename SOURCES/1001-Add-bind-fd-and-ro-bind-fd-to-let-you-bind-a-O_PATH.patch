From 766aa982697393e7ba5e73e16458ecb62dac8a34 Mon Sep 17 00:00:00 2001
From: sagar sagar <sagar.sagar@oracle.com>
Date: Tue, 17 Sep 2024 09:18:03 +0000
Subject: [PATCH 1/5] Add --bind-fd and --ro-bind-fd to let you bind a O_PATH
 fd. This is useful for example if you for some reason don't have the real
 path. It is also a way to make bind-mounts race-free (i.e. to have the mount
 actually be the thing you wanted to be mounted, avoiding issues where some
 other process replaces the target in parallel with the bwrap launch.

Unfortunately due to some technical details we can't actually directly
mount the dirfd, as they come from different user namespace which is not
permitted, but at least we can delay resolving the fd to a path as much as
possible, and then validate after mount that we actually mounted the right
thing.

Signed-off-by: Alexander Larsson <alexl@redhat.com>
upstream ref:- a253257cd298892da43e15201d83f9a02c9b58b5
Orabug: 37027734

CVE-2024-42472
Signed-off-by: sagar sagar <sagar.sagar@oracle.com>
---
 bubblewrap/bubblewrap.c | 50 +++++++++++++++++++++++++++++++++++++++++++++++++
 tests/test-run.sh       |  7 ++++++-
 2 files changed, 56 insertions(+), 1 deletion(-)

diff --git a/bubblewrap/bubblewrap.c b/bubblewrap/bubblewrap.c
index 809cf57..800df23 100644
--- a/bubblewrap/bubblewrap.c
+++ b/bubblewrap/bubblewrap.c
@@ -209,6 +209,8 @@ usage (int ecode, FILE *out)
            "    --bind SRC DEST              Bind mount the host path SRC on DEST\n"
            "    --dev-bind SRC DEST          Bind mount the host path SRC on DEST, allowing device access\n"
            "    --ro-bind SRC DEST           Bind mount the host path SRC readonly on DEST\n"
+           "    --bind-fd FD DEST            Bind open directory or path fd on DEST\n"
+           "    --ro-bind-fd FD DEST         Bind open directory or path fd read-only on DEST\n"
            "    --remount-ro DEST            Remount DEST as readonly; does not recursively remount\n"
            "    --exec-label LABEL           Exec label for the sandbox\n"
            "    --file-label LABEL           File label for temporary sandbox content\n"
@@ -995,6 +997,30 @@ setup_newroot (bool unshare_pid,
                          (op->type == SETUP_RO_BIND_MOUNT ? BIND_READONLY : 0) |
                          (op->type == SETUP_DEV_BIND_MOUNT ? BIND_DEVICES : 0),
                          source, dest);
+
+          if (op->fd >= 0)
+          {
+            struct stat fd_st, mount_st;
+
+            /* When using bind-fd, there is a race condition between resolving the fd as a magic symlink
+              * and mounting it, where someone could replace what is at the symlink target. Ideally
+              * we would not even resolve the symlink and directly bind-mount from the fd, but unfortunately
+              * we can't do that, because its not permitted to bind mount a fd from another user namespace.
+              * So, we resolve, mount and then compare fstat+stat to detect the race. */
+
+            if (fstat(op->fd, &fd_st) != 0)
+              die_with_error("Can't stat fd %d", op->fd);
+            if (lstat(dest, &mount_st) != 0)
+              die_with_error("Can't stat mount at %s", dest);
+
+            if (fd_st.st_ino != mount_st.st_ino ||
+                fd_st.st_dev != mount_st.st_dev)
+              die_with_error("Race condition binding dirfd");
+
+            close(op->fd);
+            op->fd = -1;
+          }
+          
           break;
 
         case SETUP_REMOUNT_RO_NO_RECURSIVE:
@@ -1509,6 +1535,30 @@ parse_args_recurse (int          *argcp,
           argv += 2;
           argc -= 2;
         }
+      else if (strcmp (arg, "--bind-fd") == 0 ||
+               strcmp (arg, "--ro-bind-fd") == 0)
+        {
+          int src_fd;
+          char *endptr;
+
+          if (argc < 3)
+            die ("--bind-fd takes two arguments");
+
+          src_fd = strtol (argv[1], &endptr, 10);
+          if (argv[1][0] == 0 || endptr[0] != 0 || src_fd < 0)
+            die ("Invalid fd: %s", argv[1]);
+
+          if (strcmp(arg, "--ro-bind-fd") == 0)
+            op = setup_op_new (SETUP_RO_BIND_MOUNT);
+          else
+            op = setup_op_new (SETUP_BIND_MOUNT);
+          op->source = xasprintf ("/proc/self/fd/%d", src_fd);
+          op->fd = src_fd;
+          op->dest = argv[2];
+
+          argv += 2;
+          argc -= 2;
+        }
       else if (strcmp (arg, "--dev-bind") == 0)
         {
           if (argc < 3)
diff --git a/tests/test-run.sh b/tests/test-run.sh
index ab2c008..7375b2e 100755
--- a/tests/test-run.sh
+++ b/tests/test-run.sh
@@ -23,7 +23,7 @@ set -euo pipefail
 
 skip_without_bwrap
 
-echo "1..13"
+echo "1..14"
 
 setup_repo
 install_repo
@@ -378,3 +378,8 @@ fi
 assert_file_has_content err2.txt [Ii]nvalid
 
 echo "ok no setuid"
+
+echo "foobar" > file-data
+$RUN --proc /proc --dev /dev --bind / / --bind-fd 100 /tmp cat /tmp/file-data 100< . > stdout
+assert_file_has_content stdout foobar
+echo "ok - bind-fd"
\ No newline at end of file
-- 
1.8.3.1

